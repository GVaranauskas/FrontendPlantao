OBJETIVO: Criar endpoint de health check para monitoramento de disponibilidade do sistema, verificando status do banco de dados, Redis, APIs externas e serviços críticos.

CONTEXTO: Health checks são essenciais para monitoramento em produção, permitindo que ferramentas de orquestração (Kubernetes, Docker) e APM detectem problemas automaticamente.

ARQUIVOS A CRIAR/MODIFICAR:
1. server/routes/health.routes.ts (CRIAR NOVO)
2. server/routes.ts (registrar rotas)

PASSO 1: CRIAR ARQUIVO DE ROTAS DE HEALTH

Crie o arquivo server/routes/health.routes.ts:
```typescript
import { Router } from 'express';
import { storage } from '../storage';
import { intelligentCache } from '../services/intelligent-cache.service';
import { env } from '../config/env';
import { logger } from '../lib/logger';

const router = Router();

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  uptime: number;
  version: string;
  checks: {
    database: CheckResult;
    redis: CheckResult;
    openai: CheckResult;
    filesystem: CheckResult;
  };
}

interface CheckResult {
  status: 'pass' | 'warn' | 'fail';
  message: string;
  responseTime?: number;
  details?: any;
}

/**
 * GET /health - Health check simples (liveness probe)
 */
router.get('/', async (req, res) => {
  res.status(200).json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

/**
 * GET /health/ready - Readiness check completo
 */
router.get('/ready', async (req, res) => {
  const startTime = Date.now();
  const health: HealthStatus = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: Math.floor(process.uptime()),
    version: process.env.npm_package_version || '1.0.0',
    checks: {
      database: await checkDatabase(),
      redis: await checkRedis(),
      openai: await checkOpenAI(),
      filesystem: checkFilesystem()
    }
  };

  // Determina status geral
  const checks = Object.values(health.checks);
  const hasFail = checks.some(c => c.status === 'fail');
  const hasWarn = checks.some(c => c.status === 'warn');

  if (hasFail) {
    health.status = 'unhealthy';
  } else if (hasWarn) {
    health.status = 'degraded';
  }

  const responseTime = Date.now() - startTime;
  logger.info(`[Health] Check completed in ${responseTime}ms - Status: ${health.status}`);

  // Status HTTP baseado no resultado
  const statusCode = health.status === 'healthy' ? 200 : 
                     health.status === 'degraded' ? 200 : 503;

  res.status(statusCode).json({
    ...health,
    responseTime
  });
});

/**
 * GET /health/metrics - Métricas do sistema
 */
router.get('/metrics', async (req, res) => {
  const memUsage = process.memoryUsage();
  const cacheStats = intelligentCache.getStats();

  res.json({
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: {
      rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
      heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
      external: `${Math.round(memUsage.external / 1024 / 1024)}MB`
    },
    cache: {
      entries: cacheStats.totalEntries,
      hitRate: `${cacheStats.hitRate.toFixed(1)}%`,
      totalHits: cacheStats.totalHits,
      totalMisses: cacheStats.totalMisses,
      evictions: cacheStats.evictions
    },
    process: {
      pid: process.pid,
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch
    }
  });
});

// ===== FUNÇÕES DE CHECK =====

async function checkDatabase(): Promise<CheckResult> {
  const start = Date.now();
  try {
    // Tenta uma query simples
    await storage.getAllUsers();
    const responseTime = Date.now() - start;

    if (responseTime > 5000) {
      return {
        status: 'warn',
        message: 'Database responding slowly',
        responseTime,
        details: { threshold: '5s', actual: `${responseTime}ms` }
      };
    }

    return {
      status: 'pass',
      message: 'Database connection healthy',
      responseTime
    };
  } catch (error) {
    return {
      status: 'fail',
      message: 'Database connection failed',
      responseTime: Date.now() - start,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}

async function checkRedis(): Promise<CheckResult> {
  const start = Date.now();
  try {
    const isUsingRedis = intelligentCache.isUsingRedis();
    const responseTime = Date.now() - start;

    if (!isUsingRedis) {
      return {
        status: 'warn',
        message: 'Redis not configured, using memory cache',
        responseTime,
        details: { fallback: 'memory' }
      };
    }

    // Testa operação simples
    await intelligentCache.set('health:check', { test: true }, {
      ttlMinutes: 1,
      criticality: 'low'
    });
    const retrieved = await intelligentCache.get('health:check');

    if (!retrieved) {
      return {
        status: 'warn',
        message: 'Redis write/read test failed',
        responseTime
      };
    }

    return {
      status: 'pass',
      message: 'Redis connection healthy',
      responseTime
    };
  } catch (error) {
    return {
      status: 'warn',
      message: 'Redis check failed, using fallback',
      responseTime: Date.now() - start,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}

async function checkOpenAI(): Promise<CheckResult> {
  const start = Date.now();
  try {
    if (!env.OPENAI_API_KEY) {
      return {
        status: 'warn',
        message: 'OpenAI API key not configured',
        responseTime: Date.now() - start,
        details: { configured: false }
      };
    }

    // Não fazemos chamada real para não gastar dinheiro
    // Apenas verificamos se a chave está configurada
    return {
      status: 'pass',
      message: 'OpenAI API key configured',
      responseTime: Date.now() - start,
      details: { configured: true, model: env.OPENAI_MODEL }
    };
  } catch (error) {
    return {
      status: 'fail',
      message: 'OpenAI check failed',
      responseTime: Date.now() - start,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}

function checkFilesystem(): CheckResult {
  const start = Date.now();
  try {
    const fs = require('fs');
    const path = require('path');
    
    // Verifica se pode escrever em /tmp
    const testFile = path.join('/tmp', `health-check-${Date.now()}.txt`);
    fs.writeFileSync(testFile, 'health check', 'utf8');
    fs.readFileSync(testFile, 'utf8');
    fs.unlinkSync(testFile);

    return {
      status: 'pass',
      message: 'Filesystem read/write healthy',
      responseTime: Date.now() - start
    };
  } catch (error) {
    return {
      status: 'fail',
      message: 'Filesystem check failed',
      responseTime: Date.now() - start,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}

export default router;
```

PASSO 2: REGISTRAR ROTAS DE HEALTH

No arquivo server/routes.ts, adicione ANTES de todas as outras rotas (no início da função registerRoutes):
```typescript
export async function registerRoutes(app: Express): Promise<Server> {
  // ==========================================
  // Health Check Routes (PRIMEIRO - sem auth)
  // ==========================================
  const healthRoutes = (await import('./routes/health.routes')).default;
  app.use('/health', healthRoutes);

  // ... resto das rotas existentes ...
```

VALIDAÇÃO APÓS APLICAR:
1. Servidor reinicia sem erros
2. Todas as rotas de health funcionam
3. Status codes corretos retornados

TESTES:

1. Health check simples (liveness):
```bash
curl http://localhost:5000/health
```
Retorna:
```json
{
  "status": "ok",
  "timestamp": "2024-12-29T10:00:00.000Z",
  "uptime": 123
}
```

2. Readiness check completo:
```bash
curl http://localhost:5000/health/ready
```
Retorna:
```json
{
  "status": "healthy",
  "timestamp": "2024-12-29T10:00:00.000Z",
  "uptime": 123,
  "version": "1.0.0",
  "checks": {
    "database": {
      "status": "pass",
      "message": "Database connection healthy",
      "responseTime": 45
    },
    "redis": {
      "status": "pass",
      "message": "Redis connection healthy",
      "responseTime": 12
    },
    "openai": {
      "status": "pass",
      "message": "OpenAI API key configured",
      "responseTime": 1,
      "details": { "configured": true, "model": "gpt-4o-mini" }
    },
    "filesystem": {
      "status": "pass",
      "message": "Filesystem read/write healthy",
      "responseTime": 8
    }
  },
  "responseTime": 66
}
```

3. Métricas do sistema:
```bash
curl http://localhost:5000/health/metrics
```
Retorna:
```json
{
  "timestamp": "2024-12-29T10:00:00.000Z",
  "uptime": 123,
  "memory": {
    "rss": "120MB",
    "heapUsed": "45MB",
    "heapTotal": "80MB",
    "external": "2MB"
  },
  "cache": {
    "entries": 156,
    "hitRate": "78.5%",
    "totalHits": 234,
    "totalMisses": 64,
    "evictions": 12
  },
  "process": {
    "pid": 1234,
    "nodeVersion": "v20.x.x",
    "platform": "linux",
    "arch": "x64"
  }
}
```

USO EM PRODUÇÃO:

Kubernetes/Docker:
```yaml
livenessProbe:
  httpGet:
    path: /health
    port: 5000
  initialDelaySeconds: 10
  periodSeconds: 30

readinessProbe:
  httpGet:
    path: /health/ready
    port: 5000
  initialDelaySeconds: 15
  periodSeconds: 10
```

Monitoramento:
- Status 200 = Sistema saudável
- Status 503 = Sistema não disponível
- Alertar se readiness fail por mais de 2 minutos

IMPORTANTE:
- Rotas NÃO requerem autenticação (públicas)
- Checks são rápidos (timeout implícito)
- Não expõe dados sensíveis
- Status codes semânticos (200/503)
- Logs informativos para debug

CHECKLIST DE SUCESSO:
☐ Arquivo health.routes.ts criado
☐ Rotas registradas no routes.ts
☐ Servidor reinicia sem erros
☐ GET /health retorna 200
☐ GET /health/ready retorna status correto
☐ GET /health/metrics retorna métricas
☐ Checks de database, redis, openai funcionam
☐ Status codes corretos (200 ou 503)
☐ Logs aparecem no console