üìù PROMPT 11: IMPLEMENTAR PAGINA√á√ÉO NA ROTA DE PACIENTES
OBJETIVO: Adicionar pagina√ß√£o na rota GET /api/patients para melhorar performance quando h√° muitos pacientes cadastrados, evitando carregar milhares de registros de uma vez.

CONTEXTO: Atualmente a rota retorna TODOS os pacientes de uma vez, o que pode ser lento e consumir muita mem√≥ria quando h√° centenas ou milhares de registros. Vamos implementar pagina√ß√£o padr√£o.

ARQUIVOS A MODIFICAR:
1. server/routes.ts
2. server/storage.ts (interface j√° existe, apenas usar)
3. server/repositories/postgres-storage.ts (implementar getPatientsPaginated)

PASSO 1: MODIFICAR ROTA DE PACIENTES

No arquivo server/routes.ts, localize a rota GET /api/patients e substitua por:
```typescript
app.get("/api/patients", 
  authMiddleware,
  requireRole('admin', 'enfermagem'),
  asyncHandler(async (req, res) => {
    // Par√¢metros de pagina√ß√£o (query params)
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 50;
    const usePagination = req.query.paginate !== 'false'; // Default: true

    // Se n√£o quiser pagina√ß√£o, retornar todos (retrocompatibilidade)
    if (!usePagination) {
      const patients = await storage.getAllPatients();
      const acceptToon = isToonFormat(req.get("accept"));
      if (acceptToon) {
        const toonData = stringifyToToon(patients);
        res.type("application/toon").send(toonData);
      } else {
        res.json(patients);
      }
      return;
    }

    // Com pagina√ß√£o
    const result = await storage.getPatientsPaginated({ page, limit });
    
    // Adiciona headers de pagina√ß√£o para cliente
    res.setHeader('X-Total-Count', result.total.toString());
    res.setHeader('X-Total-Pages', result.totalPages.toString());
    res.setHeader('X-Current-Page', result.page.toString());
    res.setHeader('X-Per-Page', result.limit.toString());

    const acceptToon = isToonFormat(req.get("accept"));
    if (acceptToon) {
      const toonData = stringifyToToon({
        data: result.data,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages
        }
      });
      res.type("application/toon").send(toonData);
    } else {
      res.json({
        data: result.data,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages,
          hasNext: result.page < result.totalPages,
          hasPrev: result.page > 1
        }
      });
    }
  })
);
```

PASSO 2: IMPLEMENTAR getPatientsPaginated NO STORAGE

No arquivo server/repositories/postgres-storage.ts, adicione o m√©todo:
```typescript
async getPatientsPaginated(params: PaginationParams): Promise<PaginatedResult<Patient>> {
  const page = Math.max(1, params.page || 1);
  const limit = Math.min(100, Math.max(1, params.limit || 50)); // Max 100 por p√°gina
  const offset = (page - 1) * limit;

  try {
    // Busca total de registros (com cache para 1 minuto)
    const totalResult = await this.db
      .select({ count: sql<number>`count(*)::int` })
      .from(patients);
    const total = totalResult[0]?.count || 0;

    // Busca p√°gina espec√≠fica
    const data = await this.db
      .select()
      .from(patients)
      .orderBy(desc(patients.importedAt), desc(patients.dataInternacao))
      .limit(limit)
      .offset(offset);

    const totalPages = Math.ceil(total / limit);

    return {
      data,
      total,
      page,
      limit,
      totalPages
    };
  } catch (error) {
    logger.error('[Storage] Error in getPatientsPaginated:', error);
    throw error;
  }
}
```

Certifique-se de importar `desc` no topo do arquivo:
```typescript
import { desc, eq, sql } from "drizzle-orm";
```

PASSO 3: ATUALIZAR MEMORY STORAGE (FALLBACK)

No arquivo server/repositories/memory-storage.ts, adicione:
```typescript
async getPatientsPaginated(params: PaginationParams): Promise<PaginatedResult<Patient>> {
  const page = Math.max(1, params.page || 1);
  const limit = Math.min(100, Math.max(1, params.limit || 50));
  const offset = (page - 1) * limit;

  const allPatients = Array.from(this.patients.values());
  const total = allPatients.length;
  const totalPages = Math.ceil(total / limit);
  
  // Ordena por data de importa√ß√£o (mais recente primeiro)
  allPatients.sort((a, b) => {
    const dateA = a.importedAt ? new Date(a.importedAt).getTime() : 0;
    const dateB = b.importedAt ? new Date(b.importedAt).getTime() : 0;
    return dateB - dateA;
  });

  const data = allPatients.slice(offset, offset + limit);

  return {
    data,
    total,
    page,
    limit,
    totalPages
  };
}
```

VALIDA√á√ÉO AP√ìS APLICAR:
1. Servidor reinicia sem erros
2. GET /api/patients funciona normalmente (sem query params)
3. GET /api/patients?page=1&limit=10 retorna 10 pacientes
4. Headers de pagina√ß√£o s√£o retornados
5. Frontend n√£o quebrou

EXEMPLOS DE USO:

Sem pagina√ß√£o (retrocompat√≠vel):
```bash
curl http://localhost:5000/api/patients?paginate=false
# Retorna todos
```

Com pagina√ß√£o (padr√£o):
```bash
curl http://localhost:5000/api/patients
# Retorna primeira p√°gina (50 itens)

curl http://localhost:5000/api/patients?page=2&limit=20
# Retorna segunda p√°gina (20 itens)
```

Resposta com pagina√ß√£o:
```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 50,
    "total": 234,
    "totalPages": 5,
    "hasNext": true,
    "hasPrev": false
  }
}
```

Headers retornados:
X-Total-Count: 234
X-Total-Pages: 5
X-Current-Page: 1
X-Per-Page: 50

ATUALIZAR FRONTEND (OPCIONAL - N√ÉO OBRIGAT√ìRIO AGORA):

Se quiser usar pagina√ß√£o no frontend, modifique o hook:
```typescript
// Em client/src/hooks/usePatients.ts
export function usePatients(page = 1, limit = 50) {
  return useQuery({
    queryKey: ['patients', page, limit],
    queryFn: async () => {
      const res = await fetch(`/api/patients?page=${page}&limit=${limit}`);
      return res.json();
    }
  });
}
```

IMPORTANTE:
- Pagina√ß√£o √© OPCIONAL (paginate=false para desabilitar)
- Retrocompat√≠vel com c√≥digo existente
- Limite m√°ximo de 100 por p√°gina (seguran√ßa)
- Headers informativos para cliente
- Ordena√ß√£o por data (mais recentes primeiro)
- N√ÉO quebra funcionalidade existente

PERFORMANCE ESPERADA:
- Antes: 234 pacientes = 2-5 segundos
- Depois: 50 pacientes = 0.1-0.5 segundos (10x mais r√°pido!)

CHECKLIST DE SUCESSO:
‚òê Rota GET /api/patients atualizada
‚òê getPatientsPaginated implementado no postgres-storage
‚òê getPatientsPaginated implementado no memory-storage
‚òê Import de desc adicionado
‚òê Servidor reinicia sem erros
‚òê Rota sem params funciona (50 itens)
‚òê Rota com page/limit funciona
‚òê Rota com paginate=false funciona (todos)
‚òê Headers de pagina√ß√£o presentes
‚òê Frontend n√£o quebrou