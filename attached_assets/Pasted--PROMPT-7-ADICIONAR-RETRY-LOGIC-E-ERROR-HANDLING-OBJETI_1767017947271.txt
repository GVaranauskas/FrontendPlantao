
üìù PROMPT 7: ADICIONAR RETRY LOGIC E ERROR HANDLING
OBJETIVO: Implementar retry autom√°tico com exponential backoff para chamadas √†s APIs de IA (OpenAI), tornando o sistema mais resiliente a falhas tempor√°rias de rede e rate limiting.

CONTEXTO: Atualmente, se a API do OpenAI retornar erro 429 (rate limit) ou 503 (servidor indispon√≠vel), a an√°lise falha imediatamente. Com retry logic, o sistema tentar√° novamente automaticamente.

ARQUIVOS A MODIFICAR:
1. server/services/ai-service-gpt4o-mini.ts
2. package.json (adicionar depend√™ncia)

PASSO 1: ADICIONAR DEPEND√äNCIA

Adicione ao package.json na se√ß√£o "dependencies":
```json
"p-retry": "^6.2.0"
```

Execute:
```bash
npm install
```

PASSO 2: MODIFICAR AI-SERVICE-GPT4O-MINI.TS

No arquivo server/services/ai-service-gpt4o-mini.ts, adicione o import no topo:
```typescript
import OpenAI from "openai";
import { env } from "../config/env";
import { intelligentCache } from "./intelligent-cache.service";
import { createHash } from 'node:crypto';
import pRetry from 'p-retry';  // ‚Üê ADICIONAR ESTA LINHA
```

Substitua o m√©todo callGPT4oMiniOptimized COMPLETO por esta vers√£o com retry:
```typescript
/**
 * Chama GPT-4o-mini com prompt ultra-comprimido e retry autom√°tico
 */
private async callGPT4oMiniOptimized(patient: PatientData): Promise<PatientClinicalInsights> {
  const userPrompt = this.buildUltraCompactPrompt(patient);

  // Fun√ß√£o de chamada com tratamento de erros
  const makeAPICall = async () => {
    try {
      const response = await openai.chat.completions.create({
        model: MODEL,
        messages: [
          {
            role: "system",
            content: this.COMPACT_SYSTEM_PROMPT
          },
          {
            role: "user",
            content: userPrompt
          }
        ],
        temperature: 0.3,
        max_tokens: 1000,
        response_format: { type: "json_object" },
        stream: false
      });

      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error('Resposta vazia do GPT-4o-mini');
      }

      // Valida se √© JSON v√°lido
      let analysis;
      try {
        analysis = JSON.parse(content);
      } catch (parseError) {
        throw new Error(`Resposta n√£o √© JSON v√°lido: ${content.substring(0, 100)}`);
      }

      // Valida se tem campos m√≠nimos necess√°rios
      if (!analysis.alertas || !Array.isArray(analysis.alertas)) {
        throw new Error('Resposta da IA n√£o cont√©m campo "alertas" v√°lido');
      }

      return this.transformToInsights(analysis, patient);

    } catch (error: any) {
      // Classifica o erro para decidir se deve fazer retry
      const shouldRetry = this.shouldRetryError(error);
      
      if (shouldRetry) {
        console.warn(`[GPT-4o-mini] Erro recuper√°vel (${error.status || error.code}): ${error.message}`);
        throw error; // p-retry vai tentar novamente
      } else {
        console.error(`[GPT-4o-mini] Erro n√£o recuper√°vel: ${error.message}`);
        // AbortError para p-retry n√£o tentar novamente
        throw new pRetry.AbortError(error.message);
      }
    }
  };

  // Executa com retry autom√°tico
  try {
    return await pRetry(makeAPICall, {
      retries: 3,
      minTimeout: 1000,  // 1 segundo
      maxTimeout: 10000, // 10 segundos
      factor: 2,         // Exponential backoff: 1s, 2s, 4s, 8s
      onFailedAttempt: (error) => {
        const { attemptNumber, retriesLeft } = error;
        console.warn(
          `[GPT-4o-mini] Tentativa ${attemptNumber} falhou para ${patient.leito}. ` +
          `Tentando novamente em ${error.retriesLeft > 0 ? 'alguns segundos' : 'nenhuma tentativa restante'}... ` +
          `(${retriesLeft} tentativas restantes)`
        );
      }
    });
  } catch (error: any) {
    console.error(`[GPT-4o-mini] FALHA FINAL ap√≥s todas as tentativas: ${error.message}`);
    
    // Retorna an√°lise degradada em caso de falha total
    return this.getFallbackInsights(patient);
  }
}

/**
 * Determina se um erro deve ser retentado
 */
private shouldRetryError(error: any): boolean {
  // Retry em rate limiting
  if (error.status === 429) return true;
  
  // Retry em erros de servidor (5xx)
  if (error.status >= 500 && error.status < 600) return true;
  
  // Retry em timeouts
  if (error.code === 'ETIMEDOUT' || error.code === 'ECONNRESET') return true;
  
  // Retry em erros de rede
  if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') return true;
  
  // N√ÉO retry em erros de cliente (4xx exceto 429)
  if (error.status >= 400 && error.status < 500 && error.status !== 429) return false;
  
  // Outros erros: n√£o retry
  return false;
}

/**
 * Retorna insights b√°sicos em caso de falha total da IA
 */
private getFallbackInsights(patient: PatientData): PatientClinicalInsights {
  console.warn(`[GPT-4o-mini] Usando an√°lise degradada para ${patient.leito}`);
  
  // An√°lise simplificada baseada em regras
  const alertas: any[] = [];
  
  // Verifica Braden
  const braden = parseInt(patient.braden || '999');
  if (braden <= 14) {
    alertas.push({
      tipo: 'RISCO_LESAO',
      nivel: braden <= 10 ? 'VERMELHO' : 'AMARELO',
      titulo: 'Risco de les√£o por press√£o'
    });
  }
  
  // Verifica dispositivos invasivos
  if (patient.dispositivos && patient.dispositivos.toLowerCase().includes('cateter')) {
    alertas.push({
      tipo: 'RISCO_INFECCAO',
      nivel: 'AMARELO',
      titulo: 'Dispositivos invasivos presentes'
    });
  }
  
  const nivelAlerta = alertas.some(a => a.nivel === 'VERMELHO') ? 'VERMELHO' :
                      alertas.length > 0 ? 'AMARELO' : 'VERDE';
  
  return {
    timestamp: new Date().toISOString(),
    nivel_alerta: nivelAlerta,
    alertas_count: {
      vermelho: alertas.filter(a => a.nivel === 'VERMELHO').length,
      amarelo: alertas.filter(a => a.nivel === 'AMARELO').length,
      verde: 0
    },
    principais_alertas: alertas.slice(0, 3),
    gaps_criticos: ['An√°lise completa indispon√≠vel - usando regras b√°sicas'],
    score_qualidade: 50,
    categoria_qualidade: 'REGULAR',
    prioridade_acao: 'Revisar manualmente - an√°lise autom√°tica falhou',
    recomendacoes_enfermagem: ['Realizar avalia√ß√£o manual completa do paciente']
  };
}
```

VALIDA√á√ÉO AP√ìS APLICAR:
1. Servidor reinicia sem erros
2. An√°lise de paciente continua funcionando normalmente
3. Para testar retry: desconecte internet brevemente durante an√°lise
4. Verifique logs: deve aparecer "Tentativa X falhou... Tentando novamente"

TESTE DE FALLBACK:
1. Desabilite OPENAI_API_KEY temporariamente
2. Tente analisar um paciente
3. Deve aparecer "Usando an√°lise degradada"
4. Deve retornar insights b√°sicos (n√£o vazio)

LOGS ESPERADOS EM CASO DE RETRY:
[GPT-4o-mini] Erro recuper√°vel (429): Rate limit exceeded
[GPT-4o-mini] Tentativa 1 falhou para Leito 101. Tentando novamente... (2 tentativas restantes)
[GPT-4o-mini] Tentativa 2 falhou para Leito 101. Tentando novamente... (1 tentativa restante)
[GPT-4o-mini] ‚úÖ An√°lise conclu√≠da: Leito 101 - R$ 0.03

IMPORTANTE:
- Sistema N√ÉO trava em caso de erro
- Retry autom√°tico em rate limit (429)
- Retry autom√°tico em erros de servidor (5xx)
- N√ÉO retry em erros de valida√ß√£o (4xx)
- Fallback inteligente se tudo falhar
- Logs claros para debug

CHECKLIST DE SUCESSO:
‚òê p-retry instalado (npm install executado)
‚òê Import adicionado no topo do arquivo
‚òê callGPT4oMiniOptimized atualizado
‚òê shouldRetryError implementado
‚òê getFallbackInsights implementado
‚òê Servidor reinicia sem erros
‚òê An√°lise normal funciona
‚òê Retry funciona (testar com internet inst√°vel)
‚òê Fallback funciona (testar sem API key)
‚òê Logs de retry aparecem corretamente