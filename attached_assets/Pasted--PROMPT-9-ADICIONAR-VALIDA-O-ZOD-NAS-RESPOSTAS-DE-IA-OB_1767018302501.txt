üìù PROMPT 9: ADICIONAR VALIDA√á√ÉO ZOD NAS RESPOSTAS DE IA
OBJETIVO: Adicionar valida√ß√£o rigorosa com Zod nas respostas da API de IA para garantir que sempre retornem dados estruturados v√°lidos, evitando crashes por dados malformados.

CONTEXTO: Atualmente, o sistema assume que a IA sempre retorna JSON v√°lido e bem estruturado. Se a IA retornar dados incompletos ou malformados, pode causar erros em cascata. Vamos adicionar valida√ß√£o robusta.

ARQUIVOS A MODIFICAR:
1. server/services/ai-service-gpt4o-mini.ts

PASSO 1: CRIAR SCHEMAS DE VALIDA√á√ÉO

No arquivo server/services/ai-service-gpt4o-mini.ts, adicione os schemas Zod logo ap√≥s os imports:
```typescript
import OpenAI from "openai";
import { env } from "../config/env";
import { intelligentCache } from "./intelligent-cache.service";
import { createHash } from 'node:crypto';
import pRetry from 'p-retry';
import { z } from 'zod';  // ‚Üê J√° existe, apenas confirmar

// ===== ADICIONAR ESTES SCHEMAS LOGO AP√ìS OS IMPORTS =====

const AlertaSchema = z.object({
  tipo: z.enum([
    'RISCO_QUEDA',
    'RISCO_LESAO',
    'RISCO_ASPIRACAO',
    'RISCO_INFECCAO',
    'RISCO_RESPIRATORIO',
    'RISCO_NUTRICIONAL'
  ]),
  nivel: z.enum(['VERMELHO', 'AMARELO', 'VERDE']),
  titulo: z.string().min(1, 'T√≠tulo n√£o pode ser vazio'),
  descricao: z.string().min(1, 'Descri√ß√£o n√£o pode ser vazia'),
  recomendacao: z.string().min(1, 'Recomenda√ß√£o n√£o pode ser vazia')
});

const PrioridadeSchema = z.object({
  ordem: z.number().int().min(1).max(10),
  acao: z.string().min(1, 'A√ß√£o n√£o pode ser vazia'),
  prazo: z.enum(['IMEDIATO', '2H', '6H', '24H'])
});

const AIResponseSchema = z.object({
  alertas: z.array(AlertaSchema).min(0).max(20),
  score: z.number().int().min(0).max(100),
  categoria: z.enum(['EXCELENTE', 'BOM', 'REGULAR', 'PRECISA_MELHORAR']),
  gaps: z.array(z.string()).min(0).max(50),
  prioridades: z.array(PrioridadeSchema).min(0).max(10)
});

type AIResponse = z.infer<typeof AIResponseSchema>;
```

PASSO 2: MODIFICAR callGPT4oMiniOptimized

Localize o trecho onde faz JSON.parse e substitua por valida√ß√£o com Zod:

ANTES:
```typescript
// Valida se √© JSON v√°lido
let analysis;
try {
  analysis = JSON.parse(content);
} catch (parseError) {
  throw new Error(`Resposta n√£o √© JSON v√°lido: ${content.substring(0, 100)}`);
}

// Valida se tem campos m√≠nimos necess√°rios
if (!analysis.alertas || !Array.isArray(analysis.alertas)) {
  throw new Error('Resposta da IA n√£o cont√©m campo "alertas" v√°lido');
}

return this.transformToInsights(analysis, patient);
```

DEPOIS:
```typescript
// Parse JSON
let rawAnalysis;
try {
  rawAnalysis = JSON.parse(content);
} catch (parseError) {
  console.error('[GPT-4o-mini] Resposta n√£o √© JSON v√°lido:', content.substring(0, 200));
  throw new Error('IA retornou resposta inv√°lida (n√£o √© JSON)');
}

// Valida estrutura com Zod
let analysis: AIResponse;
try {
  analysis = AIResponseSchema.parse(rawAnalysis);
  console.log(`[GPT-4o-mini] ‚úÖ Resposta validada: ${analysis.alertas.length} alertas, score ${analysis.score}`);
} catch (zodError: any) {
  console.error('[GPT-4o-mini] Erro de valida√ß√£o Zod:', zodError.errors);
  console.error('[GPT-4o-mini] Dados recebidos:', JSON.stringify(rawAnalysis, null, 2));
  
  // Tenta sanitizar os dados
  const sanitized = this.sanitizeAIResponse(rawAnalysis);
  
  try {
    analysis = AIResponseSchema.parse(sanitized);
    console.warn('[GPT-4o-mini] ‚ö†Ô∏è Resposta sanitizada e validada com sucesso');
  } catch (secondError) {
    console.error('[GPT-4o-mini] Sanitiza√ß√£o falhou, usando fallback');
    throw new Error('IA retornou dados malformados que n√£o puderam ser corrigidos');
  }
}

return this.transformToInsights(analysis, patient);
```

PASSO 3: ADICIONAR M√âTODO DE SANITIZA√á√ÉO

Adicione este novo m√©todo na classe AIServiceGPT4oMini (pode ser antes de transformToInsights):
```typescript
/**
 * Tenta sanitizar resposta malformada da IA
 */
private sanitizeAIResponse(raw: any): any {
  const sanitized: any = {
    alertas: [],
    score: 50,
    categoria: 'REGULAR',
    gaps: [],
    prioridades: []
  };

  // Sanitiza alertas
  if (Array.isArray(raw.alertas)) {
    sanitized.alertas = raw.alertas
      .filter((a: any) => a && typeof a === 'object')
      .map((a: any) => ({
        tipo: this.sanitizeEnum(a.tipo, [
          'RISCO_QUEDA', 'RISCO_LESAO', 'RISCO_ASPIRACAO',
          'RISCO_INFECCAO', 'RISCO_RESPIRATORIO', 'RISCO_NUTRICIONAL'
        ], 'RISCO_LESAO'),
        nivel: this.sanitizeEnum(a.nivel, ['VERMELHO', 'AMARELO', 'VERDE'], 'AMARELO'),
        titulo: String(a.titulo || 'Alerta sem t√≠tulo'),
        descricao: String(a.descricao || 'Sem descri√ß√£o'),
        recomendacao: String(a.recomendacao || 'Avaliar manualmente')
      }))
      .slice(0, 20); // M√°ximo 20 alertas
  }

  // Sanitiza score
  if (typeof raw.score === 'number') {
    sanitized.score = Math.max(0, Math.min(100, Math.round(raw.score)));
  } else if (typeof raw.score === 'string') {
    const parsed = parseInt(raw.score);
    sanitized.score = isNaN(parsed) ? 50 : Math.max(0, Math.min(100, parsed));
  }

  // Sanitiza categoria
  sanitized.categoria = this.sanitizeEnum(
    raw.categoria,
    ['EXCELENTE', 'BOM', 'REGULAR', 'PRECISA_MELHORAR'],
    'REGULAR'
  );

  // Sanitiza gaps
  if (Array.isArray(raw.gaps)) {
    sanitized.gaps = raw.gaps
      .filter((g: any) => typeof g === 'string' && g.trim().length > 0)
      .map((g: any) => String(g).trim())
      .slice(0, 50);
  }

  // Sanitiza prioridades
  if (Array.isArray(raw.prioridades)) {
    sanitized.prioridades = raw.prioridades
      .filter((p: any) => p && typeof p === 'object')
      .map((p: any, index: number) => ({
        ordem: typeof p.ordem === 'number' ? p.ordem : index + 1,
        acao: String(p.acao || 'A√ß√£o n√£o especificada'),
        prazo: this.sanitizeEnum(p.prazo, ['IMEDIATO', '2H', '6H', '24H'], '24H')
      }))
      .slice(0, 10);
  }

  return sanitized;
}

/**
 * Sanitiza valor para enum v√°lido
 */
private sanitizeEnum<T extends string>(
  value: any,
  validValues: T[],
  defaultValue: T
): T {
  if (typeof value === 'string') {
    const upper = value.toUpperCase();
    if (validValues.includes(upper as T)) {
      return upper as T;
    }
  }
  return defaultValue;
}
```

VALIDA√á√ÉO AP√ìS APLICAR:
1. Servidor compila sem erros
2. An√°lise de paciente funciona normalmente
3. Para testar valida√ß√£o: temporariamente modifique COMPACT_SYSTEM_PROMPT para retornar JSON inv√°lido
4. Deve aparecer logs de sanitiza√ß√£o
5. Sistema n√£o deve crashar

TESTES ESPERADOS:

Caso 1 - Resposta v√°lida:
[GPT-4o-mini] ‚úÖ Resposta validada: 3 alertas, score 75

Caso 2 - Resposta com problemas sanitiz√°veis:
[GPT-4o-mini] Erro de valida√ß√£o Zod: [...]
[GPT-4o-mini] ‚ö†Ô∏è Resposta sanitizada e validada com sucesso

Caso 3 - Resposta completamente inv√°lida:
[GPT-4o-mini] Sanitiza√ß√£o falhou, usando fallback
[GPT-4o-mini] Usando an√°lise degradada para Leito 101

IMPORTANTE:
- Sistema sempre retorna algo (nunca null/undefined)
- Valida√ß√£o rigorosa com Zod
- Sanitiza√ß√£o autom√°tica de dados malformados
- Fallback inteligente em √∫ltimo caso
- Logs detalhados para debug
- N√ÉO modifica l√≥gica de neg√≥cio

CHECKLIST DE SUCESSO:
‚òê Schemas Zod adicionados
‚òê callGPT4oMiniOptimized atualizado com valida√ß√£o
‚òê sanitizeAIResponse implementado
‚òê sanitizeEnum implementado
‚òê Servidor compila sem erros
‚òê An√°lise funciona normalmente
‚òê Logs de valida√ß√£o aparecem
‚òê Sistema n√£o quebra com dados inv√°lidos
‚òê Sempre retorna insights (nunca null)