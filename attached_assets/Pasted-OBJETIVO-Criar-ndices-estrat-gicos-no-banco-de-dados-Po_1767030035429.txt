OBJETIVO: Criar √≠ndices estrat√©gicos no banco de dados PostgreSQL para acelerar queries comuns, especialmente buscas por leito, enfermaria e status que s√£o usadas frequentemente.

CONTEXTO: Atualmente as tabelas n√£o t√™m √≠ndices al√©m das primary keys, o que torna buscas lentas quando h√° muitos registros. Com √≠ndices adequados, queries podem ser at√© 100x mais r√°pidas.

PR√â-REQUISITOS:
- Banco de dados PostgreSQL configurado e acess√≠vel
- Acesso ao DATABASE_URL

ARQUIVOS A CRIAR:
1. db/migrations/001_add_indexes.sql (CRIAR NOVO)
2. db/run-migration.ts (CRIAR NOVO - script helper)

PASSO 1: CRIAR ARQUIVO DE MIGRATION

Crie o arquivo db/migrations/001_add_indexes.sql:
```sql
-- Migration: Adicionar √≠ndices para otimiza√ß√£o de performance
-- Data: 2024
-- Descri√ß√£o: √çndices estrat√©gicos para queries comuns

-- ========================================
-- TABELA: patients
-- ========================================

-- √çndice para busca por leito (muito usado)
CREATE INDEX IF NOT EXISTS idx_patients_leito 
ON patients(leito);

-- √çndice para busca por enfermaria (filtro comum)
CREATE INDEX IF NOT EXISTS idx_patients_enfermaria 
ON patients(ds_enfermaria);

-- √çndice para busca por status (pending/complete)
CREATE INDEX IF NOT EXISTS idx_patients_status 
ON patients(status);

-- √çndice composto para busca por leito + enfermaria (combo comum)
CREATE INDEX IF NOT EXISTS idx_patients_leito_enfermaria 
ON patients(leito, ds_enfermaria);

-- √çndice para busca por data de interna√ß√£o (para ordena√ß√£o)
CREATE INDEX IF NOT EXISTS idx_patients_data_internacao 
ON patients(data_internacao);

-- √çndice para busca por fonte de dados (N8N_IAMSPE, etc)
CREATE INDEX IF NOT EXISTS idx_patients_fonte_dados 
ON patients(fonte_dados);

-- √çndice para buscas por data de importa√ß√£o (relat√≥rios)
CREATE INDEX IF NOT EXISTS idx_patients_imported_at 
ON patients(imported_at DESC);

-- ========================================
-- TABELA: import_history
-- ========================================

-- √çndice para busca por enfermaria
CREATE INDEX IF NOT EXISTS idx_import_history_enfermaria 
ON import_history(enfermaria);

-- √çndice para busca por timestamp (relat√≥rios temporais)
CREATE INDEX IF NOT EXISTS idx_import_history_timestamp 
ON import_history(timestamp DESC);

-- √çndice composto para relat√≥rios por enfermaria + data
CREATE INDEX IF NOT EXISTS idx_import_history_enfermaria_timestamp 
ON import_history(enfermaria, timestamp DESC);

-- ========================================
-- TABELA: audit_log
-- ========================================

-- √çndice para busca por usu√°rio (auditoria)
CREATE INDEX IF NOT EXISTS idx_audit_log_user_id 
ON audit_log(user_id);

-- √çndice para busca por timestamp (queries temporais)
CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp 
ON audit_log(timestamp DESC);

-- √çndice para busca por a√ß√£o (filtro comum)
CREATE INDEX IF NOT EXISTS idx_audit_log_action 
ON audit_log(action);

-- √çndice para busca por recurso
CREATE INDEX IF NOT EXISTS idx_audit_log_resource 
ON audit_log(resource);

-- √çndice para busca por status code (erros)
CREATE INDEX IF NOT EXISTS idx_audit_log_status_code 
ON audit_log(status_code);

-- ========================================
-- TABELA: nursing_units
-- ========================================

-- √çndice para busca por c√≥digo (muito usado)
CREATE INDEX IF NOT EXISTS idx_nursing_units_codigo 
ON nursing_units(codigo);

-- √çndice para busca por external_id
CREATE INDEX IF NOT EXISTS idx_nursing_units_external_id 
ON nursing_units(external_id);

-- √çndice para filtrar apenas ativos
CREATE INDEX IF NOT EXISTS idx_nursing_units_ativo 
ON nursing_units(ativo);

-- ========================================
-- TABELA: nursing_unit_changes
-- ========================================

-- √çndice para busca por status (pending/approved/rejected)
CREATE INDEX IF NOT EXISTS idx_nursing_unit_changes_status 
ON nursing_unit_changes(status);

-- √çndice para busca por external_id
CREATE INDEX IF NOT EXISTS idx_nursing_unit_changes_external_id 
ON nursing_unit_changes(external_id);

-- √çndice composto para filtrar pendentes por tipo
CREATE INDEX IF NOT EXISTS idx_nursing_unit_changes_status_type 
ON nursing_unit_changes(status, change_type);

-- ========================================
-- TABELA: users
-- ========================================

-- √çndice para busca por username (login frequente)
CREATE INDEX IF NOT EXISTS idx_users_username 
ON users(username);

-- √çndice para busca por role (controle de acesso)
CREATE INDEX IF NOT EXISTS idx_users_role 
ON users(role);

-- √çndice para filtrar apenas ativos
CREATE INDEX IF NOT EXISTS idx_users_is_active 
ON users(is_active);

-- ========================================
-- AN√ÅLISE DE PERFORMANCE
-- ========================================

-- Analisar tabelas para atualizar estat√≠sticas do PostgreSQL
ANALYZE patients;
ANALYZE import_history;
ANALYZE audit_log;
ANALYZE nursing_units;
ANALYZE nursing_unit_changes;
ANALYZE users;

-- Mensagem de conclus√£o
DO $$ 
BEGIN 
  RAISE NOTICE '‚úÖ √çndices criados com sucesso!';
  RAISE NOTICE 'Total de √≠ndices adicionados: 27';
  RAISE NOTICE 'Tabelas analisadas para otimiza√ß√£o do query planner';
END $$;
```

PASSO 2: CRIAR SCRIPT PARA EXECUTAR MIGRATION

Crie o arquivo db/run-migration.ts:
```typescript
import { neon } from '@neondatabase/serverless';
import { readFileSync } from 'fs';
import { join } from 'path';
import { env } from '../server/config/env';

async function runMigration() {
  if (!env.DATABASE_URL) {
    console.error('‚ùå DATABASE_URL n√£o configurado');
    process.exit(1);
  }

  console.log('üîÑ Conectando ao banco de dados...');
  const sql = neon(env.DATABASE_URL);

  try {
    // L√™ arquivo de migration
    const migrationPath = join(__dirname, 'migrations', '001_add_indexes.sql');
    const migrationSQL = readFileSync(migrationPath, 'utf-8');

    console.log('üìù Executando migration: 001_add_indexes.sql');
    console.log('');

    // Executa migration
    await sql(migrationSQL);

    console.log('');
    console.log('‚úÖ Migration executada com sucesso!');
    console.log('');
    console.log('üìä Verificando √≠ndices criados...');

    // Lista √≠ndices criados
    const indexes = await sql`
      SELECT 
        schemaname,
        tablename,
        indexname
      FROM pg_indexes
      WHERE schemaname = 'public'
        AND indexname LIKE 'idx_%'
      ORDER BY tablename, indexname;
    `;

    console.log(`Total de √≠ndices: ${indexes.length}`);
    console.log('');

    // Agrupa por tabela
    const byTable: Record<string, string[]> = {};
    for (const idx of indexes) {
      if (!byTable[idx.tablename]) {
        byTable[idx.tablename] = [];
      }
      byTable[idx.tablename].push(idx.indexname);
    }

    // Exibe por tabela
    for (const [table, idxList] of Object.entries(byTable)) {
      console.log(`üìã ${table}:`);
      for (const idx of idxList) {
        console.log(`   - ${idx}`);
      }
      console.log('');
    }

    console.log('‚úÖ Processo conclu√≠do!');
    
  } catch (error) {
    console.error('‚ùå Erro ao executar migration:', error);
    process.exit(1);
  }

  process.exit(0);
}

runMigration();
```

PASSO 3: ADICIONAR SCRIPT NO PACKAGE.JSON

No arquivo package.json, adicione na se√ß√£o "scripts":
```json
"scripts": {
  "dev": "NODE_ENV=development tsx server/index.ts",
  "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
  "start": "NODE_ENV=production node dist/index.js",
  "check": "tsc",
  "db:push": "drizzle-kit push",
  "db:migrate": "tsx db/run-migration.ts"
}
```

PASSO 4: EXECUTAR MIGRATION

Execute no terminal do Replit:
```bash
npm run db:migrate
```

VALIDA√á√ÉO AP√ìS APLICAR:
1. Migration executa sem erros
2. Aparece mensagem "‚úÖ Migration executada com sucesso!"
3. Lista de √≠ndices √© exibida
4. Queries continuam funcionando normalmente

VERIFICAR PERFORMANCE:

Antes dos √≠ndices:
```sql
EXPLAIN ANALYZE 
SELECT * FROM patients WHERE leito = '101';
-- Seq Scan (lento)
```

Depois dos √≠ndices:
```sql
EXPLAIN ANALYZE 
SELECT * FROM patients WHERE leito = '101';
-- Index Scan using idx_patients_leito (r√°pido!)
```

TESTE DE IMPACTO:
```sql
-- Verificar tamanho dos √≠ndices
SELECT 
  tablename,
  indexname,
  pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_indexes
JOIN pg_class ON pg_indexes.indexname = pg_class.relname
WHERE schemaname = 'public' AND indexname LIKE 'idx_%'
ORDER BY pg_relation_size(indexrelid) DESC;
```

IMPORTANTE:
- √çndices s√£o criados com IF NOT EXISTS (seguro executar m√∫ltiplas vezes)
- N√ÉO modifica dados existentes
- N√ÉO altera estrutura de tabelas
- Apenas adiciona √≠ndices para otimiza√ß√£o
- ANALYZE atualiza estat√≠sticas do planner
- Performance melhora imediatamente

ROLLBACK (se necess√°rio):
Para remover √≠ndices:
```sql
DROP INDEX IF EXISTS idx_patients_leito;
DROP INDEX IF EXISTS idx_patients_enfermaria;
-- etc...
```

CHECKLIST DE SUCESSO:
‚òê Pasta db/migrations/ criada
‚òê Arquivo 001_add_indexes.sql criado
‚òê Arquivo db/run-migration.ts criado
‚òê Script db:migrate adicionado no package.json
‚òê Migration executada sem erros
‚òê 27 √≠ndices criados
‚òê Lista de √≠ndices exibida corretamente
‚òê Queries funcionam normalmente
‚òê Performance melhorou (testar com EXPLAIN ANALYZE)