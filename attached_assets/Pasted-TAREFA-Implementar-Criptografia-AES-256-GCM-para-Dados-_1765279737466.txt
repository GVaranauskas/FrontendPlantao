TAREFA: Implementar Criptografia AES-256-GCM para Dados Sensíveis

CONTEXTO:
O sistema armazena dados de saúde em texto plano no PostgreSQL, violando LGPD Art. 46.
Campos afetados: nome, registro, dataNascimento, diagnosticoComorbidades, alergias, observacoesIntercorrencias, dsEvolucaoCompleta.

EXECUTAR:

1. Criar arquivo server/services/encryption.service.ts com:
```typescript
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'node:crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY_LENGTH = 32;
const IV_LENGTH = 16;
const SALT_LENGTH = 64;
const TAG_LENGTH = 16;
const TAG_POSITION = SALT_LENGTH + IV_LENGTH;
const ENCRYPTED_POSITION = TAG_POSITION + TAG_LENGTH;

class EncryptionService {
  private masterKey: Buffer;

  constructor() {
    const masterKeyBase64 = process.env.ENCRYPTION_KEY;
    
    if (!masterKeyBase64) {
      throw new Error('ENCRYPTION_KEY must be set in environment variables');
    }

    this.masterKey = Buffer.from(masterKeyBase64, 'base64');

    if (this.masterKey.length !== KEY_LENGTH) {
      throw new Error(`ENCRYPTION_KEY must be exactly ${KEY_LENGTH} bytes`);
    }

    console.log('[Encryption] Service initialized with AES-256-GCM');
  }

  encrypt(plaintext: string | null | undefined): string | null {
    if (!plaintext) return null;

    try {
      const salt = randomBytes(SALT_LENGTH);
      const key = scryptSync(this.masterKey, salt, KEY_LENGTH);
      const iv = randomBytes(IV_LENGTH);
      const cipher = createCipheriv(ALGORITHM, key, iv);
      
      const encrypted = Buffer.concat([
        cipher.update(plaintext, 'utf8'),
        cipher.final()
      ]);
      
      const authTag = cipher.getAuthTag();
      const result = Buffer.concat([salt, iv, authTag, encrypted]);
      
      return result.toString('base64');
    } catch (error) {
      console.error('[Encryption] Encrypt failed:', error);
      throw new Error('Encryption failed');
    }
  }

  decrypt(ciphertext: string | null | undefined): string | null {
    if (!ciphertext) return null;

    try {
      const buffer = Buffer.from(ciphertext, 'base64');
      
      const salt = buffer.slice(0, SALT_LENGTH);
      const iv = buffer.slice(SALT_LENGTH, TAG_POSITION);
      const authTag = buffer.slice(TAG_POSITION, ENCRYPTED_POSITION);
      const encrypted = buffer.slice(ENCRYPTED_POSITION);
      
      const key = scryptSync(this.masterKey, salt, KEY_LENGTH);
      const decipher = createDecipheriv(ALGORITHM, key, iv);
      decipher.setAuthTag(authTag);
      
      const decrypted = Buffer.concat([
        decipher.update(encrypted),
        decipher.final()
      ]);
      
      return decrypted.toString('utf8');
    } catch (error) {
      console.error('[Encryption] Decrypt failed:', error);
      throw new Error('Decryption failed');
    }
  }

  encryptFields<T extends Record<string, any>>(obj: T, fields: Array<keyof T>): T {
    const result = { ...obj };
    for (const field of fields) {
      if (typeof result[field] === 'string') {
        result[field] = this.encrypt(result[field] as string) as any;
      }
    }
    return result;
  }

  decryptFields<T extends Record<string, any>>(obj: T, fields: Array<keyof T>): T {
    const result = { ...obj };
    for (const field of fields) {
      if (typeof result[field] === 'string') {
        result[field] = this.decrypt(result[field] as string) as any;
      }
    }
    return result;
  }
}

export const encryptionService = new EncryptionService();
```

2. Adicionar ao .env: