Crie o arquivo /server/services/intelligent-cache.service.ts  import { createHash } from 'node:crypto'; /** * INTELLIGENT CACHE SERVICE * * Sistema de cache multi-camada para otimizar custos de APIs * - Cache de respostas de IA baseado em conteúdo * - Suporte a Prompt Caching da Anthropic (90% desconto) * - TTL inteligente baseado em estabilidade dos dados * * ECONOMIA ESTIMADA: 60-80% nos custos de IA */ interface CacheEntry<T> { key: string; value: T; contentHash: string; createdAt: Date; expiresAt:Date; hitCount: number; lastAccessed: Date; } interface CacheStats { totalEntries: number; hitRate: number; totalHits:number; totalMisses: number; memoryUsage: number; oldestEntry: Date | null; newestEntry: Date | null; } export classIntelligentCacheService { // Cache em memória (em produção, usar Redis) private cache: Map<string,CacheEntry<any>> = new Map(); // Estatísticas private stats = { hits: 0, misses: 0, evictions: 0 }; // Configurações de TTL (em minutos) private defaultTTL = 60; // 1 hora private stableTTL = 240; // 4 horas (para dados estáveis) privatecriticalTTL = 15; // 15 minutos (para dados críticos) /** * Busca valor no cache baseado em hash de conteúdo */ get<T>(key: string, contentHash?: string): T | null { const entry = this.cache.get(key); if (!entry) { this.stats.misses++;console.log(`[Cache] MISS: ${key}`); return null; } // Verifica expiração if (new Date() > entry.expiresAt) {this.cache.delete(key); this.stats.misses++; this.stats.evictions++; console.log(`[Cache] EXPIRED: ${key}`); return null; }// Se forneceu hash, verifica se conteúdo mudou if (contentHash && entry.contentHash !== contentHash) {this.cache.delete(key); this.stats.misses++; console.log(`[Cache] CONTENT_CHANGED: ${key}`); return null; } // Cache HIT! entry.hitCount++; entry.lastAccessed = new Date(); this.stats.hits++; console.log(`[Cache] HIT: ${key}(${entry.hitCount} hits)`); return entry.value; } /** * Armazena valor no cache */ set<T>( key: string, value: T, options?:{ contentHash?: string; ttlMinutes?: number; isStable?: boolean; isCritical?: boolean; } ): void { const ttl =options?.ttlMinutes ? options.ttlMinutes : options?.isStable ? this.stableTTL : options?.isCritical ? this.criticalTTL :this.defaultTTL; const entry: CacheEntry<T> = { key, value, contentHash: options?.contentHash ||this.generateContentHash(value), createdAt: new Date(), expiresAt: new Date(Date.now() + ttl * 60 * 1000), hitCount: 0,lastAccessed: new Date() }; this.cache.set(key, entry); console.log(`[Cache] SET: ${key} (TTL: ${ttl}min)`); } /** * Gera hash do conteúdo para comparação */ private generateContentHash(content: any): string { const jsonString =JSON.stringify(content); return createHash('md5').update(jsonString).digest('hex'); } /** * Gera chave de cache para análise de paciente */ generatePatientAnalysisKey(patientId: string, analysisType: string): string { return`patient:${patientId}:${analysisType}`; } /** * Gera chave de cache para análise de múltiplos pacientes */generateBatchAnalysisKey(patientIds: string[], analysisType: string): string { const idsHash =createHash('md5').update(patientIds.sort().join(',')).digest('hex'); return `batch:${idsHash}:${analysisType}`; } /** * Invalida cache de um paciente específico */ invalidatePatient(patientId: string): number { let invalidated = 0; const prefix = `patient:${patientId}:`; for (const key of this.cache.keys()) { if (key.startsWith(prefix)) { this.cache.delete(key);invalidated++; } } if (invalidated > 0) { console.log(`[Cache] Invalidated ${invalidated} entries for patient ${patientId}`);} return invalidated; } /** * Invalida cache de análises em lote */ invalidateBatch(): number { let invalidated = 0; for(const key of this.cache.keys()) { if (key.startsWith('batch:')) { this.cache.delete(key); invalidated++; } } if (invalidated >0) { console.log(`[Cache] Invalidated ${invalidated} batch entries`); } return invalidated; } /** * Limpa entradas expiradas */ cleanupExpired(): number { const now = new Date(); let cleaned = 0; for (const [key, entry] ofthis.cache.entries()) { if (now > entry.expiresAt) { this.cache.delete(key); cleaned++; } } if (cleaned > 0) {this.stats.evictions += cleaned; console.log(`[Cache] Cleaned ${cleaned} expired entries`); } return cleaned; } /** * Limpa cache completo */ clear(): void { const size = this.cache.size; this.cache.clear(); console.log(`[Cache] Cleared ${size} entries`); } /** * Retorna estatísticas detalhadas */ getStats(): CacheStats { const entries =Array.from(this.cache.values()); const memoryUsage = JSON.stringify(entries).length; const dates = entries.map(e =>e.createdAt.getTime()); const oldestEntry = dates.length > 0 ? new Date(Math.min(...dates)) : null; const newestEntry =dates.length > 0 ? new Date(Math.max(...dates)) : null; const totalRequests = this.stats.hits + this.stats.misses; consthitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0; return { totalEntries: this.cache.size, hitRate:Math.round(hitRate * 100) / 100, totalHits: this.stats.hits, totalMisses: this.stats.misses, memoryUsage, oldestEntry,newestEntry }; } /** * Estima economia de custos baseada no hit rate */ estimateSavings(averageCostPerCall: number =0.50): { savedCalls: number; savedCost: number; hitRatePercent: number; } { const stats = this.getStats(); constsavedCalls = this.stats.hits; const savedCost = savedCalls * averageCostPerCall; return { savedCalls, savedCost:Math.round(savedCost * 100) / 100, hitRatePercent: stats.hitRate }; } /** * Retorna entradas mais acessadas (hot cache)*/ getHotEntries(limit: number = 10): Array<{ key: string; hitCount: number; age: number; }> { const entries =Array.from(this.cache.values()) .sort((a, b) => b.hitCount - a.hitCount) .slice(0, limit); return entries.map(e => ({ key:e.key, hitCount: e.hitCount, age: Date.now() - e.createdAt.getTime() })); } /** * Implementa LRU (Least Recently Used) eviction * Mantém cache dentro de um tamanho máximo */ enforceSizeLimit(maxEntries: number = 1000): number { if(this.cache.size <= maxEntries) return 0; const entries = Array.from(this.cache.entries()) .sort((a, b) =>a[1].lastAccessed.getTime() - b[1].lastAccessed.getTime()); const toRemove = this.cache.size - maxEntries; let removed = 0; for (let i = 0; i < toRemove; i++) { this.cache.delete(entries[i][0]); removed++; } this.stats.evictions += removed;console.log(`[Cache] LRU eviction: removed ${removed} entries`); return removed; } /** * Reseta estatísticas */resetStats(): void { this.stats = { hits: 0, misses: 0, evictions: 0 }; console.log('[Cache] Stats reset'); } } /** * PROMPT CACHE HELPER * * Funções auxiliares para usar Prompt Caching da Anthropic * Ref: https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching */ export class PromptCacheHelper { /** * Marca blocos do system prompt como cacheáveis * Economia: 90% no custo de tokens em cache */ staticbuildCacheableSystemPrompt(systemPrompt: string): Array<{ type: 'text'; text: string; cache_control?: { type:'ephemeral' }; }> { return [ { type: 'text', text: systemPrompt, cache_control: { type: 'ephemeral' } } ]; } /** * Prepara mensagens com cache control * Use para prompts grandes que se repetem */ static prepareCachedMessages(systemPrompt: string, userMessage: string ): { system: Array<{ type: 'text'; text: string; cache_control?: { type:'ephemeral' } }>; messages: Array<{ role: 'user'; content: string }>; } { return { system:this.buildCacheableSystemPrompt(systemPrompt), messages: [ { role: 'user', content: userMessage } ] }; } /** * Calcula economia estimada com prompt caching */ static estimateCacheSavings( systemPromptTokens: number, callsPerDay:number, cacheHitRate: number = 0.9 // 90% hit rate típico ): { tokensSavedPerDay: number; costSavedPerDay: number;costSavedPerMonth: number; } { // Preço Anthropic (aproximado em R$) const inputTokenPrice = 0.000003; // R$ por token input const cachedTokenPrice = 0.0000003; // R$ por token cached (10% do preço) const savingsPerToken =inputTokenPrice - cachedTokenPrice; const tokensSavedPerDay = systemPromptTokens * callsPerDay * cacheHitRate;const costSavedPerDay = tokensSavedPerDay * savingsPerToken; const costSavedPerMonth = costSavedPerDay * 30;return { tokensSavedPerDay: Math.round(tokensSavedPerDay), costSavedPerDay: Math.round(costSavedPerDay * 100) /100, costSavedPerMonth: Math.round(costSavedPerMonth * 100) / 100 }; } } export const intelligentCacheService = newIntelligentCacheService(); export const promptCacheHelper = PromptCacheHelper; IMPORTANTE: - Cache em memória (em produção usar Redis) - TTL inteligente baseado em criticidade - Hit rate tracking Confirme quando criado.